---
title: "Getting Started with SvelteKit Remote Functions"
excerpt: "How SvelteKit's Remote Functions let you write type-safe server logic and call it directly from your components."
author: "Rifky Adni Putra"
date: "2025-10-16"
readTime: "7 min read"
tags: ["SvelteKit", "remote functions", "web development", "RPC"]
featured: false
slug: "sveltekit-remote-functions-guide"
---

SvelteKit has introduced **Remote Functions** — an experimental feature aiming to streamline how you write server logic and call it safely from your components. In effect, it gives you an RPC-style paradigm, but with full type safety and automatic fetch wrapping. ([svelte.dev][1])


## Why Remote Functions?

Traditionally, SvelteKit’s data fetching and mutations rely on:

* `load` / `+page.server.js` / `+layout.server.js` for server-side data loading ([svelte.dev][2])
* Endpoint files (e.g. `+server.ts`) or actions for mutations
* `fetch` calls from client-side or through `load` functions

While this works, it can sometimes feel disjointed:

* You may have to jump between endpoints and component code
* Type safety of client ↔ server communication can be weak
* Co-location is limited: logic tied to UI components may feel separate

Remote Functions aim to fix that. You write server-only logic in `.remote.ts` (or `.remote.js`) files, and import them in your Svelte components. On the server, they run directly; on the client, they compile to `fetch` wrappers under the hood. ([GitHub][3])

They also provide type-safe serialization of arguments (via devalue) and runtime validation if you opt in with a schema.

In Svelte’s docs:

> Remote functions are a tool for type-safe communication between client and server. They can be called anywhere in your app, but always run on the server. ([svelte.dev][1])

The feature is experimental, so you have to explicitly enable it. ([GitHub][3])

---

## Enabling Remote Functions

To opt into this experimental feature, you need to adjust your SvelteKit configuration:

```js
// svelte.config.js
/** @type {import('@sveltejs/kit').Config} */
const config = {
  kit: {
    experimental: {
      remoteFunctions: true
    }
  },
  compilerOptions: {
    experimental: {
      async: true
    }
  }
};

export default config;
```

* `kit.experimental.remoteFunctions = true` turns on remote functions support. ([svelte.dev][1])
* `compilerOptions.experimental.async = true` allows you to use `await` at the top level inside Svelte components (needed for `await remoteQuery()`) ([GitHub][3])

Once enabled, you can create files with suffix `.remote.ts` (or `.remote.js`) anywhere in your `src` (or routes) folder. The functions you export from them become your “remote” functions.

---

## The Four Flavors of Remote Functions

Remote functions come in four types:

1. **query** — for fetching data (read)
2. **command** — for server-side mutations (writes)
3. **form** — for form handling (like actions, but built-in)
4. **prerender** — for build-time data logic

Let’s dive into each.

### `query`

A `query` is a function meant to fetch data. Its signature usually looks like:

```ts
import { query } from '$app/server';

export const getPosts = query(async () => {
  // server logic: fetch from DB, external API, etc.
  return await fetchSomePosts();
});
```

You can also provide input validation:

```ts
import { query } from '$app/server';
import { z } from 'zod';

export const getUser = query(z.string(), async (userId) => {
  return await fetchUserById(userId);
});
```

On the client side (inside a Svelte component), you can do:

```svelte
<script lang="ts">
  import { getPosts } from './posts.remote';

  const posts = await getPosts();
</script>

{#each posts as post}
  <div>{post.title}</div>
{/each}
```

Under the hood, SvelteKit generates a `fetch` wrapper for `getPosts` when used in the client. ([svelte.dev][1])

`query` also supports `batch` mode, where multiple calls can be aggregated in a single request. ([svelte.dev][4])

You can also manage loading/error states more explicitly:

```svelte
<script>
  import { getPosts } from './posts.remote';

  const q = getPosts(); // now q has `loading`, `error`, `current`
</script>

{#if q.error}
  <p>Error: {q.error.message}</p>
{:else if q.loading}
  <p>Loading...</p>
{:else}
  <ul>
    {#each q.current as post}
      <li>{post.title}</li>
    {/each}
  </ul>
{/if}
```

You can also call `q.refresh()` to re-fetch. ([svelte.dev][1])

### `command`

`command` is for mutations or actions (server side). It wraps server-side logic that changes state:

```ts
import { command } from '$app/server';

export const addLike = command(async (postId: string) => {
  await incrementLikesInDatabase(postId);
  return { success: true };
});
```

On the client, invoking `addLike(postId)` results in a remote call. You can also chain `updates(...)` to trigger query invalidations or optimistic updates. ([svelte.dev][5])

### `form`

`form` is particularly suited for form submissions. It produces an object you can spread onto a `<form>` element in your Svelte component:

```ts
// comments.remote.ts
import { form } from '$app/server';
import { z } from 'zod';

const commentSchema = z.object({
  postId: z.string(),
  content: z.string().min(1)
});

export const addComment = form(commentSchema, async (data, invalid) => {
  if (invalid) {
    return { success: false, errors: invalid };
  }
  await createComment(data.postId, data.content);
  return { success: true };
});
```

In your component:

```svelte
<script lang="ts">
  import { addComment } from './comments.remote';

  let result;
</script>

<form {...addComment}>
  <input name="postId" type="hidden" value={postId} />
  <textarea name="content"></textarea>
  <button type="submit">Submit</button>
</form>

{#if addComment.result?.success}
  <p>Comment added!</p>
{:else if addComment.result?.errors}
  <p>Errors: {JSON.stringify(addComment.result.errors)}</p>
{/if}
```

It also supports `enhance(...)` for custom handling or optimistic updates. ([svelte.dev][5])

### `prerender`

This is for build-time logic: you can compute values at build time (during prerender) that your components can use. It’s less commonly needed in dynamic apps but useful for static parts. ([svelte.dev][4])

---

## Example: A Simple Todos App

Let’s sketch a minimal example using `query` + `command`.

**File `todos.remote.ts`**

```ts
import { query, command } from '$app/server';

interface Todo {
  id: string;
  text: string;
  done: boolean;
}

// In memory store (for demo)
let todos: Todo[] = [
  { id: "1", text: "Buy milk", done: false }
];

export const getTodos = query(async () => {
  return todos;
});

export const addTodo = command(async (text: string) => {
  const newTodo: Todo = { id: crypto.randomUUID(), text, done: false };
  todos = [ ...todos, newTodo ];
  return newTodo;
});

export const toggleTodo = command(async (id: string) => {
  todos = todos.map((t) =>
    t.id === id ? { ...t, done: !t.done } : t
  );
  return { success: true };
});
```

**In your Svelte component, e.g. `+page.svelte`**

```svelte
<script lang="ts">
  import { getTodos, addTodo, toggleTodo } from './todos.remote';

  const todos = await getTodos();

  async function handleAdd(event: SubmitEvent) {
    event.preventDefault();
    const form = event.currentTarget as HTMLFormElement;
    const text = (form.elements.namedItem('text') as HTMLInputElement).value;
    await addTodo(text).updates(getTodos());
  }

  async function handleToggle(id: string) {
    await toggleTodo(id).updates(getTodos());
  }
</script>

<form on:submit={handleAdd}>
  <input name="text" />
  <button type="submit">Add</button>
</form>

<ul>
  {#each todos as t}
    <li>
      <label>
        <input
          type="checkbox"
          checked={t.done}
          on:change={() => handleToggle(t.id)} />
        {t.text}
      </label>
    </li>
  {/each}
</ul>
```

Note how we can call server methods (`addTodo`, `toggleTodo`) directly from the component without writing a separate API route. The `.updates(getTodos())` tells SvelteKit: after this command completes, refresh that query (or apply an optimistic update). ([svelte.dev][1])

---

## Best Practices & Gotchas

### ✅ Use validation schemas

If your remote function expects input, validate it via a schema (e.g. `zod`) so malformed input is caught early. Without validation, everything is “unchecked.”

### ✅ Co-locate logic near usage

One of the biggest strengths: keep remote logic close to your UI so you don’t have to jump across directories.

### ✅ Be cautious with heavy logic

A remote function runs on the server and might block or slow down performance. Avoid putting very heavy tasks that should be delegated elsewhere.

### ✅ Understand SSR / hydration behavior

Because remote functions always run on server, even during SSR/hydration, they need to work without depending on browser globals. Also, if you call a query during SSR, SvelteKit may inline its result in HTML so it isn’t refetched on hydration. ([svelte.dev][1])

### ⚠️ Experimental, API may change

Remote Functions is still experimental as of 2025; expect changes. ([svelte.dev][1])

### ⚠️ Don’t leak secrets accidentally

Because the client import is compiled to a fetch wrapper, you should never place secrets or environment variables in a `.remote.ts` function. But as always, be mindful of what your functions can access.

---

## What Remote Functions Solve (and What They Don’t)

### Pros

* **Colocation**: logic lives next to UI
* **Type safety**: client and server share types
* **Cleaner API calls**: you don’t need to manually write endpoints and fetch calls
* **Automatic serialization and caching**
* **Optimistic updates and query invalidation built in**

### Limitations / things to watch

* Sometimes `load` is still more appropriate, especially when wanting to bundle multiple data fetches for a page
* Not a full replacement for API-only backends (if you have a completely separate backend, bridging may need extra glue)
* Because it’s experimental, behavior might shift
* Current limitations in SSR / hydration edge cases

As one commenter put it:

> “I was sick of setting up +server.js just to run one DB query. Can't wait to delete half my API routes.” ([Reddit][6])

Remote Functions don’t necessarily remove `load` functions entirely — they complement them. For example, `load` works at the page-level, bundling multiple data needs together, while remote functions give you more granular control.



## Conclusion & What's Next

SvelteKit’s Remote Functions open a new paradigm: writing server logic that feels like local functions, with type safety and automatic fetch plumbing. For many apps, this will reduce boilerplate and bring code much closer to UI.

As this feature matures, I expect:

* Better tooling (IDE support, debugging)
* Wider adoption of batching or automatic deduplication
* More patterns and best practices emerging

If you’re trying it today, treat it as experimental but powerful.


Want more examples or a deeper dive into `form.enhance`, query batching, or handling file uploads via Remote Functions? Let me know — I’d be happy to expand with real-world demos.

[1]: https://svelte.dev/docs/kit/remote-functions?utm_source=chatgpt.com "Remote functions • Docs - Svelte"
[2]: https://svelte.dev/docs/kit/load?utm_source=chatgpt.com "Loading data • Docs - Svelte"
[3]: https://github.com/sveltejs/kit/discussions/13897?utm_source=chatgpt.com "Remote Functions · sveltejs kit · Discussion #13897 - GitHub"
[4]: https://svelte.dev/docs/kit/%24app-server?utm_source=chatgpt.com "$app/server • Docs - Svelte"
[5]: https://svelte.dev/docs/kit/%40sveltejs-kit?utm_source=chatgpt.com "@sveltejs/kit • Docs • Svelte"
[6]: https://www.reddit.com/r/sveltejs/comments/1ldv5cr/new_sveltekit_concept_remote_functions/?utm_source=chatgpt.com "New SvelteKit concept: Remote functions : r/sveltejs - Reddit"
